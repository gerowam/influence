<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on April 2, 2015 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>Untitled Document</title>

<meta name="description" content="Untitled Document">
<meta name="keywords" content="Untitled Document">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="index-blocks"></a>
<a name="index-vectors"></a>
<a name="index-matrices"></a>

<p>The functions described in this chapter provide a simple vector and
matrix interface to ordinary C arrays. The memory management of these
arrays is implemented using a single underlying type, known as a
block. By writing your functions in terms of vectors and matrices you
can pass a single structure containing both data and dimensions as an
argument without needing additional function parameters.  The structures
are compatible with the vector and matrix formats used by <small>BLAS</small>
routines.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Data-types">1. Data types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                  
</td></tr>
<tr><td align="left" valign="top"><a href="#Blocks">2. Blocks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                      
</td></tr>
<tr><td align="left" valign="top"><a href="#Vectors">3. Vectors</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     
</td></tr>
<tr><td align="left" valign="top"><a href="#Matrices">4. Matrices</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    
</td></tr>
<tr><td align="left" valign="top"><a href="#Vector-and-Matrix-References-and-Further-Reading">5. References and Further Reading</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<a name="Data-types"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[ &lt; ]</td>
<td valign="middle" align="left">[<a href="#Blocks" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[ &lt;&lt; ]</td>
<td valign="middle" align="left">[ Up ]</td>
<td valign="middle" align="left">[<a href="#Blocks" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Data-types-1"></a>
<h2 class="section">1. Data types</h2>

<p>All the functions are available for each of the standard data-types.
The versions for <code>double</code> have the prefix <code>gsl_block</code>,
<code>gsl_vector</code> and <code>gsl_matrix</code>.  Similarly the versions for
single-precision <code>float</code> arrays have the prefix
<code>gsl_block_float</code>, <code>gsl_vector_float</code> and
<code>gsl_matrix_float</code>.  The full list of available types is given
below,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">gsl_block                       double         
gsl_block_float                 float         
gsl_block_long_double           long double   
gsl_block_int                   int           
gsl_block_uint                  unsigned int  
gsl_block_long                  long          
gsl_block_ulong                 unsigned long 
gsl_block_short                 short         
gsl_block_ushort                unsigned short
gsl_block_char                  char          
gsl_block_uchar                 unsigned char 
gsl_block_complex               complex double        
gsl_block_complex_float         complex float         
gsl_block_complex_long_double   complex long double   
</pre></td></tr></table>

<p>Corresponding types exist for the <code>gsl_vector</code> and
<code>gsl_matrix</code> functions.
</p>


<hr size="6">
<a name="Blocks"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Data-types" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Block-allocation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-types" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Blocks-1"></a>
<h2 class="section">2. Blocks</h2>
<a name="index-gsl_005fblock"></a>
<p>For consistency all memory is allocated through a <code>gsl_block</code>
structure.  The structure contains two components, the size of an area of
memory and a pointer to the memory.  The <code>gsl_block</code> structure looks
like this,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct
{
  size_t size;
  double * data;
} gsl_block;
</pre></td></tr></table>

<p>Vectors and matrices are made by <em>slicing</em> an underlying block. A
slice is a set of elements formed from an initial offset and a
combination of indices and step-sizes. In the case of a matrix the
step-size for the column index represents the row-length.  The step-size
for a vector is known as the <em>stride</em>.
</p>
<p>The functions for allocating and deallocating blocks are defined in
&lsquo;<tt>gsl_block.h</tt>&rsquo;
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Block-allocation">2.1 Block allocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            
</td></tr>
<tr><td align="left" valign="top"><a href="#Reading-and-writing-blocks">2.2 Reading and writing blocks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Example-programs-for-blocks">2.3 Example programs for blocks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Block-allocation"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Blocks" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-and-writing-blocks" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Blocks" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Blocks" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Block-allocation-1"></a>
<h3 class="subsection">2.1 Block allocation</h3>

<p>The functions for allocating memory to a block follow the style of
<code>malloc</code> and <code>free</code>.  In addition they also perform their own
error checking.  If there is insufficient memory available to allocate a
block then the functions call the GSL error handler (with an error
number of <code>GSL_ENOMEM</code>) in addition to returning a null
pointer.  Thus if you use the library error handler to abort your program
then it isn&rsquo;t necessary to check every <code>alloc</code>.  
</p>
<dl>
<dt><a name="index-gsl_005fblock_005falloc"></a><u>Function:</u> gsl_block * <b>gsl_block_alloc</b><i> (size_t <var>n</var>)</i></dt>
<dd><p>This function allocates memory for a block of <var>n</var> double-precision
elements, returning a pointer to the block struct.  The block is not
initialized and so the values of its elements are undefined.  Use the
function <code>gsl_block_calloc</code> if you want to ensure that all the
elements are initialized to zero.
</p>
<p>A null pointer is returned if insufficient memory is available to create
the block.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fblock_005fcalloc"></a><u>Function:</u> gsl_block * <b>gsl_block_calloc</b><i> (size_t <var>n</var>)</i></dt>
<dd><p>This function allocates memory for a block and initializes all the
elements of the block to zero.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fblock_005ffree"></a><u>Function:</u> void <b>gsl_block_free</b><i> (gsl_block * <var>b</var>)</i></dt>
<dd><p>This function frees the memory used by a block <var>b</var> previously
allocated with <code>gsl_block_alloc</code> or <code>gsl_block_calloc</code>.
</p></dd></dl>

<hr size="6">
<a name="Reading-and-writing-blocks"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Block-allocation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Example-programs-for-blocks" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Blocks" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Blocks" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Reading-and-writing-blocks-1"></a>
<h3 class="subsection">2.2 Reading and writing blocks</h3>

<p>The library provides functions for reading and writing blocks to a file
as binary data or formatted text.
</p>
<dl>
<dt><a name="index-gsl_005fblock_005ffwrite"></a><u>Function:</u> int <b>gsl_block_fwrite</b><i> (FILE * <var>stream</var>, const gsl_block * <var>b</var>)</i></dt>
<dd><p>This function writes the elements of the block <var>b</var> to the stream
<var>stream</var> in binary format.  The return value is 0 for success and
<code>GSL_EFAILED</code> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fblock_005ffread"></a><u>Function:</u> int <b>gsl_block_fread</b><i> (FILE * <var>stream</var>, gsl_block * <var>b</var>)</i></dt>
<dd><p>This function reads into the block <var>b</var> from the open stream
<var>stream</var> in binary format.  The block <var>b</var> must be preallocated
with the correct length since the function uses the size of <var>b</var> to
determine how many bytes to read.  The return value is 0 for success and
<code>GSL_EFAILED</code> if there was a problem reading from the file.  The
data is assumed to have been written in the native binary format on the
same architecture.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fblock_005ffprintf"></a><u>Function:</u> int <b>gsl_block_fprintf</b><i> (FILE * <var>stream</var>, const gsl_block * <var>b</var>, const char * <var>format</var>)</i></dt>
<dd><p>This function writes the elements of the block <var>b</var> line-by-line to
the stream <var>stream</var> using the format specifier <var>format</var>, which
should be one of the <code>%g</code>, <code>%e</code> or <code>%f</code> formats for
floating point numbers and <code>%d</code> for integers.  The function returns
0 for success and <code>GSL_EFAILED</code> if there was a problem writing to
the file.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fblock_005ffscanf"></a><u>Function:</u> int <b>gsl_block_fscanf</b><i> (FILE * <var>stream</var>, gsl_block * <var>b</var>)</i></dt>
<dd><p>This function reads formatted data from the stream <var>stream</var> into the
block <var>b</var>.  The block <var>b</var> must be preallocated with the correct
length since the function uses the size of <var>b</var> to determine how many
numbers to read.  The function returns 0 for success and
<code>GSL_EFAILED</code> if there was a problem reading from the file.
</p></dd></dl>

<hr size="6">
<a name="Example-programs-for-blocks"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-and-writing-blocks" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Blocks" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Blocks" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Example-programs-for-blocks-1"></a>
<h3 class="subsection">2.3 Example programs for blocks</h3>

<p>The following program shows how to allocate a block,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_block.h&gt;

int
main (void)
{
  gsl_block * b = gsl_block_alloc (100);
  
  printf (&quot;length of block = %u\n&quot;, b-&gt;size);
  printf (&quot;block data address = %#x\n&quot;, b-&gt;data);

  gsl_block_free (b);
  return 0;
}
</pre></pre></td></tr></table>

<p>Here is the output from the program,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><pre class="verbatim">length of block = 100
block data address = 0x804b0d8
</pre></pre></td></tr></table>

<hr size="6">
<a name="Vectors"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Example-programs-for-blocks" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-allocation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Blocks" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-types" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Vectors-1"></a>
<h2 class="section">3. Vectors</h2>
<a name="index-vectors-1"></a>
<a name="index-stride_002c-of-vector-index"></a>

<p>Vectors are defined by a <code>gsl_vector</code> structure which describes a
slice of a block.  Different vectors can be created which point to the
same block.  A vector slice is a set of equally-spaced elements of an
area of memory.
</p>
<a name="index-gsl_005fvector"></a>
<p>The <code>gsl_vector</code> structure contains five components, the
<em>size</em>, the <em>stride</em>, a pointer to the memory where the elements
are stored, <var>data</var>, a pointer to the block owned by the vector,
<var>block</var>, if any, and an ownership flag, <var>owner</var>.  The structure
is very simple and looks like this,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct
{
  size_t size;
  size_t stride;
  double * data;
  gsl_block * block;
  int owner;
} gsl_vector;
</pre></td></tr></table>

<p>The <var>size</var> is simply the number of vector elements.  The range of
valid indices runs from 0 to <code>size-1</code>.  The <var>stride</var> is the
step-size from one element to the next in physical memory, measured in
units of the appropriate datatype.  The pointer <var>data</var> gives the
location of the first element of the vector in memory.  The pointer
<var>block</var> stores the location of the memory block in which the vector
elements are located (if any).  If the vector owns this block then the
<var>owner</var> field is set to one and the block will be deallocated when the
vector is freed.  If the vector points to a block owned by another
object then the <var>owner</var> field is zero and any underlying block will not be
deallocated with the vector.
</p>
<p>The functions for allocating and accessing vectors are defined in
&lsquo;<tt>gsl_vector.h</tt>&rsquo;
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Vector-allocation">3.1 Vector allocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           
</td></tr>
<tr><td align="left" valign="top"><a href="#Accessing-vector-elements">3.2 Accessing vector elements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   
</td></tr>
<tr><td align="left" valign="top"><a href="#Initializing-vector-elements">3.3 Initializing vector elements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Reading-and-writing-vectors">3.4 Reading and writing vectors</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Vector-views">3.5 Vector views</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                
</td></tr>
<tr><td align="left" valign="top"><a href="#Copying-vectors">3.6 Copying vectors</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             
</td></tr>
<tr><td align="left" valign="top"><a href="#Exchanging-elements">3.7 Exchanging elements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">         
</td></tr>
<tr><td align="left" valign="top"><a href="#Vector-operations">3.8 Vector operations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           
</td></tr>
<tr><td align="left" valign="top"><a href="#Finding-maximum-and-minimum-elements-of-vectors">3.9 Finding maximum and minimum elements of vectors</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Vector-properties">3.10 Vector properties</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           
</td></tr>
<tr><td align="left" valign="top"><a href="#Example-programs-for-vectors">3.11 Example programs for vectors</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Vector-allocation"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Vectors" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Accessing-vector-elements" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Vector-allocation-1"></a>
<h3 class="subsection">3.1 Vector allocation</h3>

<p>The functions for allocating memory to a vector follow the style of
<code>malloc</code> and <code>free</code>.  In addition they also perform their own
error checking.  If there is insufficient memory available to allocate a
vector then the functions call the GSL error handler (with an error
number of <code>GSL_ENOMEM</code>) in addition to returning a null
pointer.  Thus if you use the library error handler to abort your program
then it isn&rsquo;t necessary to check every <code>alloc</code>.
</p>
<dl>
<dt><a name="index-gsl_005fvector_005falloc"></a><u>Function:</u> gsl_vector * <b>gsl_vector_alloc</b><i> (size_t <var>n</var>)</i></dt>
<dd><p>This function creates a vector of length <var>n</var>, returning a pointer to
a newly initialized vector struct. A new block is allocated for the
elements of the vector, and stored in the <var>block</var> component of the
vector struct.  The block is &ldquo;owned&rdquo; by the vector, and will be
deallocated when the vector is deallocated.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fcalloc"></a><u>Function:</u> gsl_vector * <b>gsl_vector_calloc</b><i> (size_t <var>n</var>)</i></dt>
<dd><p>This function allocates memory for a vector of length <var>n</var> and
initializes all the elements of the vector to zero.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005ffree"></a><u>Function:</u> void <b>gsl_vector_free</b><i> (gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function frees a previously allocated vector <var>v</var>.  If the
vector was created using <code>gsl_vector_alloc</code> then the block
underlying the vector will also be deallocated.  If the vector has
been created from another object then the memory is still owned by
that object and will not be deallocated.
</p></dd></dl>

<hr size="6">
<a name="Accessing-vector-elements"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Vector-allocation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Initializing-vector-elements" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Accessing-vector-elements-1"></a>
<h3 class="subsection">3.2 Accessing vector elements</h3>
<a name="index-vectors_002c-range_002dchecking"></a>
<a name="index-range_002dchecking-for-vectors"></a>
<a name="index-bounds-checking_002c-extension-to-GCC"></a>
<a name="index-gcc-extensions_002c-range_002dchecking"></a>
<a name="index-Fortran-range-checking_002c-equivalent-in-gcc"></a>

<p>Unlike <small>FORTRAN</small> compilers, C compilers do not usually provide
support for range checking of vectors and matrices.<a name="DOCF1" href="#FOOT1">(1)</a>  The functions <code>gsl_vector_get</code> and
<code>gsl_vector_set</code> can perform portable range checking for you and
report an error if you attempt to access elements outside the allowed
range.
</p>
<p>The functions for accessing the elements of a vector or matrix are
defined in &lsquo;<tt>gsl_vector.h</tt>&rsquo; and declared <code>extern inline</code> to
eliminate function-call overhead.  You must compile your program with
the preprocessor macro <code>HAVE_INLINE</code> defined to use these
functions.
</p>
<a name="index-GSL_005fRANGE_005fCHECK_005fOFF"></a>
<p>If necessary you can turn off range checking completely without
modifying any source files by recompiling your program with the
preprocessor definition <code>GSL_RANGE_CHECK_OFF</code>.  Provided your
compiler supports inline functions the effect of turning off range
checking is to replace calls to <code>gsl_vector_get(v,i)</code> by
<code>v-&gt;data[i*v-&gt;stride]</code> and calls to <code>gsl_vector_set(v,i,x)</code> by
<code>v-&gt;data[i*v-&gt;stride]=x</code>.  Thus there should be no performance
penalty for using the range checking functions when range checking is
turned off.
</p>
<a name="index-GSL_005fC99_005fINLINE"></a>
<p>If you use a C99 compiler which requires inline functions in header
files to be declared <code>inline</code> instead of <code>extern inline</code>,
define the macro <code>GSL_C99_INLINE</code> (@pxref{Inline functions}).
With GCC this is selected automatically when compiling in C99 mode
(<code>-std=c99</code>).
</p>
<a name="index-gsl_005fcheck_005frange"></a>
<p>If inline functions are not used, calls to the functions
<code>gsl_vector_get</code> and <code>gsl_vector_set</code> will link to the
compiled versions of these functions in the library itself.  The range
checking in these functions is controlled by the global integer
variable <code>gsl_check_range</code>.  It is enabled by default&mdash;to
disable it, set <code>gsl_check_range</code> to zero.  Due to function-call
overhead, there is less benefit in disabling range checking here than
for inline functions.
</p>
<dl>
<dt><a name="index-gsl_005fvector_005fget"></a><u>Function:</u> double <b>gsl_vector_get</b><i> (const gsl_vector * <var>v</var>, const size_t <var>i</var>)</i></dt>
<dd><p>This function returns the <var>i</var>-th element of a vector <var>v</var>.  If
<var>i</var> lies outside the allowed range of 0 to <em><var>n</var>-1</em> then the error
handler is invoked and 0 is returned.  @inlinefn{}
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fset"></a><u>Function:</u> void <b>gsl_vector_set</b><i> (gsl_vector * <var>v</var>, const size_t <var>i</var>, double <var>x</var>)</i></dt>
<dd><p>This function sets the value of the <var>i</var>-th element of a vector
<var>v</var> to <var>x</var>.  If <var>i</var> lies outside the allowed range of 0 to
<em><var>n</var>-1</em> then the error handler is invoked.  @inlinefn{}
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fptr"></a><u>Function:</u> double * <b>gsl_vector_ptr</b><i> (gsl_vector * <var>v</var>, size_t <var>i</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fconst_005fptr"></a><u>Function:</u> const double * <b>gsl_vector_const_ptr</b><i> (const gsl_vector * <var>v</var>, size_t <var>i</var>)</i></dt>
<dd><p>These functions return a pointer to the <var>i</var>-th element of a vector
<var>v</var>.  If <var>i</var> lies outside the allowed range of 0 to <em><var>n</var>-1</em>
then the error handler is invoked and a null pointer is returned.  @inlinefns{}
</p></dd></dl>

<hr size="6">
<a name="Initializing-vector-elements"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Accessing-vector-elements" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-and-writing-vectors" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Initializing-vector-elements-1"></a>
<h3 class="subsection">3.3 Initializing vector elements</h3>
<a name="index-vectors_002c-initializing"></a>
<a name="index-initializing-vectors"></a>

<dl>
<dt><a name="index-gsl_005fvector_005fset_005fall"></a><u>Function:</u> void <b>gsl_vector_set_all</b><i> (gsl_vector * <var>v</var>, double <var>x</var>)</i></dt>
<dd><p>This function sets all the elements of the vector <var>v</var> to the value
<var>x</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fset_005fzero"></a><u>Function:</u> void <b>gsl_vector_set_zero</b><i> (gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function sets all the elements of the vector <var>v</var> to zero.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fset_005fbasis"></a><u>Function:</u> int <b>gsl_vector_set_basis</b><i> (gsl_vector * <var>v</var>, size_t <var>i</var>)</i></dt>
<dd><p>This function makes a basis vector by setting all the elements of the
vector <var>v</var> to zero except for the <var>i</var>-th element which is set to
one.
</p></dd></dl>

<hr size="6">
<a name="Reading-and-writing-vectors"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Initializing-vector-elements" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-views" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Reading-and-writing-vectors-1"></a>
<h3 class="subsection">3.4 Reading and writing vectors</h3>

<p>The library provides functions for reading and writing vectors to a file
as binary data or formatted text.
</p>
<dl>
<dt><a name="index-gsl_005fvector_005ffwrite"></a><u>Function:</u> int <b>gsl_vector_fwrite</b><i> (FILE * <var>stream</var>, const gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function writes the elements of the vector <var>v</var> to the stream
<var>stream</var> in binary format.  The return value is 0 for success and
<code>GSL_EFAILED</code> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005ffread"></a><u>Function:</u> int <b>gsl_vector_fread</b><i> (FILE * <var>stream</var>, gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function reads into the vector <var>v</var> from the open stream
<var>stream</var> in binary format.  The vector <var>v</var> must be preallocated
with the correct length since the function uses the size of <var>v</var> to
determine how many bytes to read.  The return value is 0 for success and
<code>GSL_EFAILED</code> if there was a problem reading from the file.  The
data is assumed to have been written in the native binary format on the
same architecture.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005ffprintf"></a><u>Function:</u> int <b>gsl_vector_fprintf</b><i> (FILE * <var>stream</var>, const gsl_vector * <var>v</var>, const char * <var>format</var>)</i></dt>
<dd><p>This function writes the elements of the vector <var>v</var> line-by-line to
the stream <var>stream</var> using the format specifier <var>format</var>, which
should be one of the <code>%g</code>, <code>%e</code> or <code>%f</code> formats for
floating point numbers and <code>%d</code> for integers.  The function returns
0 for success and <code>GSL_EFAILED</code> if there was a problem writing to
the file.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005ffscanf"></a><u>Function:</u> int <b>gsl_vector_fscanf</b><i> (FILE * <var>stream</var>, gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function reads formatted data from the stream <var>stream</var> into the
vector <var>v</var>.  The vector <var>v</var> must be preallocated with the correct
length since the function uses the size of <var>v</var> to determine how many
numbers to read.  The function returns 0 for success and
<code>GSL_EFAILED</code> if there was a problem reading from the file.
</p></dd></dl>

<hr size="6">
<a name="Vector-views"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-and-writing-vectors" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Copying-vectors" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Vector-views-1"></a>
<h3 class="subsection">3.5 Vector views</h3>

<p>In addition to creating vectors from slices of blocks it is also
possible to slice vectors and create vector views.  For example, a
subvector of another vector can be described with a view, or two views
can be made which provide access to the even and odd elements of a
vector.
</p>
<a name="index-gsl_005fvector_005fview"></a>
<a name="index-gsl_005fvector_005fconst_005fview"></a>
<p>A vector view is a temporary object, stored on the stack, which can be
used to operate on a subset of vector elements.  Vector views can be
defined for both constant and non-constant vectors, using separate types
that preserve constness.  A vector view has the type
<code>gsl_vector_view</code> and a constant vector view has the type
<code>gsl_vector_const_view</code>.  In both cases the elements of the view
can be accessed as a <code>gsl_vector</code> using the <code>vector</code> component
of the view object.  A pointer to a vector of type <code>gsl_vector *</code>
or <code>const gsl_vector *</code> can be obtained by taking the address of
this component with the <code>&amp;</code> operator.  
</p>
<p>When using this pointer it is important to ensure that the view itself
remains in scope&mdash;the simplest way to do so is by always writing the
pointer as <code>&amp;</code><var>view</var><code>.vector</code>, and never storing this value
in another variable.  
</p>
<dl>
<dt><a name="index-gsl_005fvector_005fsubvector"></a><u>Function:</u> gsl_vector_view <b>gsl_vector_subvector</b><i> (gsl_vector * <var>v</var>, size_t <var>offset</var>, size_t <var>n</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fconst_005fsubvector"></a><u>Function:</u> gsl_vector_const_view <b>gsl_vector_const_subvector</b><i> (const gsl_vector * <var>v</var>, size_t <var>offset</var>, size_t <var>n</var>)</i></dt>
<dd><p>These functions return a vector view of a subvector of another vector
<var>v</var>.  The start of the new vector is offset by <var>offset</var> elements
from the start of the original vector.  The new vector has <var>n</var>
elements.  Mathematically, the <var>i</var>-th element of the new vector
<var>v&rsquo;</var> is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">v'(i) = v-&gt;data[(offset + i)*v-&gt;stride]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n-1</code>.
</p>
<p>The <code>data</code> pointer of the returned vector struct is set to null if
the combined parameters (<var>offset</var>,<var>n</var>) overrun the end of the
original vector.
</p>
<p>The new vector is only a view of the block underlying the original
vector, <var>v</var>.  The block containing the elements of <var>v</var> is not
owned by the new vector.  When the view goes out of scope the original
vector <var>v</var> and its block will continue to exist.  The original
memory can only be deallocated by freeing the original vector.  Of
course, the original vector should not be deallocated while the view is
still in use.
</p>
<p>The function <code>gsl_vector_const_subvector</code> is equivalent to
<code>gsl_vector_subvector</code> but can be used for vectors which are
declared <code>const</code>.
</p></dd></dl>


<dl>
<dt><a name="index-gsl_005fvector_005fsubvector_005fwith_005fstride"></a><u>Function:</u> gsl_vector_view <b>gsl_vector_subvector_with_stride</b><i> (gsl_vector * <var>v</var>, size_t <var>offset</var>, size_t <var>stride</var>, size_t <var>n</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fconst_005fsubvector_005fwith_005fstride"></a><u>Function:</u> gsl_vector_const_view <b>gsl_vector_const_subvector_with_stride</b><i> (const gsl_vector * <var>v</var>, size_t <var>offset</var>, size_t <var>stride</var>, size_t <var>n</var>)</i></dt>
<dd><p>These functions return a vector view of a subvector of another vector
<var>v</var> with an additional stride argument. The subvector is formed in
the same way as for <code>gsl_vector_subvector</code> but the new vector has
<var>n</var> elements with a step-size of <var>stride</var> from one element to
the next in the original vector.  Mathematically, the <var>i</var>-th element
of the new vector <var>v&rsquo;</var> is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">v'(i) = v-&gt;data[(offset + i*stride)*v-&gt;stride]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n-1</code>.
</p>
<p>Note that subvector views give direct access to the underlying elements
of the original vector. For example, the following code will zero the
even elements of the vector <code>v</code> of length <code>n</code>, while leaving the
odd elements untouched,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">gsl_vector_view v_even 
  = gsl_vector_subvector_with_stride (v, 0, 2, n/2);
gsl_vector_set_zero (&amp;v_even.vector);
</pre></td></tr></table>

<p>A vector view can be passed to any subroutine which takes a vector
argument just as a directly allocated vector would be, using
<code>&amp;</code><var>view</var><code>.vector</code>.  For example, the following code
computes the norm of the odd elements of <code>v</code> using the <small>BLAS</small>
routine <small>DNRM2</small>,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">gsl_vector_view v_odd 
  = gsl_vector_subvector_with_stride (v, 1, 2, n/2);
double r = gsl_blas_dnrm2 (&amp;v_odd.vector);
</pre></td></tr></table>

<p>The function <code>gsl_vector_const_subvector_with_stride</code> is equivalent
to <code>gsl_vector_subvector_with_stride</code> but can be used for vectors
which are declared <code>const</code>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fcomplex_005freal"></a><u>Function:</u> gsl_vector_view <b>gsl_vector_complex_real</b><i> (gsl_vector_complex * <var>v</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fcomplex_005fconst_005freal"></a><u>Function:</u> gsl_vector_const_view <b>gsl_vector_complex_const_real</b><i> (const gsl_vector_complex * <var>v</var>)</i></dt>
<dd><p>These functions return a vector view of the real parts of the complex
vector <var>v</var>.
</p>
<p>The function <code>gsl_vector_complex_const_real</code> is equivalent to
<code>gsl_vector_complex_real</code> but can be used for vectors which are
declared <code>const</code>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fcomplex_005fimag"></a><u>Function:</u> gsl_vector_view <b>gsl_vector_complex_imag</b><i> (gsl_vector_complex * <var>v</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fcomplex_005fconst_005fimag"></a><u>Function:</u> gsl_vector_const_view <b>gsl_vector_complex_const_imag</b><i> (const gsl_vector_complex * <var>v</var>)</i></dt>
<dd><p>These functions return a vector view of the imaginary parts of the
complex vector <var>v</var>.
</p>
<p>The function <code>gsl_vector_complex_const_imag</code> is equivalent to
<code>gsl_vector_complex_imag</code> but can be used for vectors which are
declared <code>const</code>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fview_005farray"></a><u>Function:</u> gsl_vector_view <b>gsl_vector_view_array</b><i> (double * <var>base</var>, size_t <var>n</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fconst_005fview_005farray"></a><u>Function:</u> gsl_vector_const_view <b>gsl_vector_const_view_array</b><i> (const double * <var>base</var>, size_t <var>n</var>)</i></dt>
<dd><p>These functions return a vector view of an array.  The start of the new
vector is given by <var>base</var> and has <var>n</var> elements.  Mathematically,
the <var>i</var>-th element of the new vector <var>v&rsquo;</var> is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">v'(i) = base[i]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n-1</code>.
</p>
<p>The array containing the elements of <var>v</var> is not owned by the new
vector view.  When the view goes out of scope the original array will
continue to exist.  The original memory can only be deallocated by
freeing the original pointer <var>base</var>.  Of course, the original array
should not be deallocated while the view is still in use.
</p>
<p>The function <code>gsl_vector_const_view_array</code> is equivalent to
<code>gsl_vector_view_array</code> but can be used for arrays which are
declared <code>const</code>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fview_005farray_005fwith_005fstride"></a><u>Function:</u> gsl_vector_view <b>gsl_vector_view_array_with_stride</b><i> (double * <var>base</var>, size_t <var>stride</var>, size_t <var>n</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fconst_005fview_005farray_005fwith_005fstride"></a><u>Function:</u> gsl_vector_const_view <b>gsl_vector_const_view_array_with_stride</b><i> (const double * <var>base</var>, size_t <var>stride</var>, size_t <var>n</var>)</i></dt>
<dd><p>These functions return a vector view of an array <var>base</var> with an
additional stride argument. The subvector is formed in the same way as
for <code>gsl_vector_view_array</code> but the new vector has <var>n</var> elements
with a step-size of <var>stride</var> from one element to the next in the
original array.  Mathematically, the <var>i</var>-th element of the new
vector <var>v&rsquo;</var> is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">v'(i) = base[i*stride]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n-1</code>.
</p>
<p>Note that the view gives direct access to the underlying elements of the
original array.  A vector view can be passed to any subroutine which
takes a vector argument just as a directly allocated vector would be,
using <code>&amp;</code><var>view</var><code>.vector</code>.
</p>
<p>The function <code>gsl_vector_const_view_array_with_stride</code> is
equivalent to <code>gsl_vector_view_array_with_stride</code> but can be used
for arrays which are declared <code>const</code>.
</p></dd></dl>




<hr size="6">
<a name="Copying-vectors"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Vector-views" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Exchanging-elements" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Copying-vectors-1"></a>
<h3 class="subsection">3.6 Copying vectors</h3>

<p>Common operations on vectors such as addition and multiplication are
available in the <small>BLAS</small> part of the library (@pxref{BLAS
Support}).  However, it is useful to have a small number of utility
functions which do not require the full <small>BLAS</small> code.  The following
functions fall into this category.
</p>
<dl>
<dt><a name="index-gsl_005fvector_005fmemcpy"></a><u>Function:</u> int <b>gsl_vector_memcpy</b><i> (gsl_vector * <var>dest</var>, const gsl_vector * <var>src</var>)</i></dt>
<dd><p>This function copies the elements of the vector <var>src</var> into the
vector <var>dest</var>.  The two vectors must have the same length.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fswap"></a><u>Function:</u> int <b>gsl_vector_swap</b><i> (gsl_vector * <var>v</var>, gsl_vector * <var>w</var>)</i></dt>
<dd><p>This function exchanges the elements of the vectors <var>v</var> and <var>w</var>
by copying.  The two vectors must have the same length.
</p></dd></dl>


<hr size="6">
<a name="Exchanging-elements"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Copying-vectors" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-operations" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Exchanging-elements-1"></a>
<h3 class="subsection">3.7 Exchanging elements</h3>

<p>The following function can be used to exchange, or permute, the elements
of a vector.
</p>
<dl>
<dt><a name="index-gsl_005fvector_005fswap_005felements"></a><u>Function:</u> int <b>gsl_vector_swap_elements</b><i> (gsl_vector * <var>v</var>, size_t <var>i</var>, size_t <var>j</var>)</i></dt>
<dd><p>This function exchanges the <var>i</var>-th and <var>j</var>-th elements of the
vector <var>v</var> in-place.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005freverse"></a><u>Function:</u> int <b>gsl_vector_reverse</b><i> (gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function reverses the order of the elements of the vector <var>v</var>.
</p></dd></dl>


<hr size="6">
<a name="Vector-operations"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Exchanging-elements" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Finding-maximum-and-minimum-elements-of-vectors" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Vector-operations-1"></a>
<h3 class="subsection">3.8 Vector operations</h3>

<dl>
<dt><a name="index-gsl_005fvector_005fadd"></a><u>Function:</u> int <b>gsl_vector_add</b><i> (gsl_vector * <var>a</var>, const gsl_vector * <var>b</var>)</i></dt>
<dd><p>This function adds the elements of vector <var>b</var> to the elements of
vector <var>a</var>.  The result <em>a_i \leftarrow a_i + b_i</em> is stored
in <var>a</var> and <var>b</var> remains unchanged.  The two vectors must have
the same length.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fsub"></a><u>Function:</u> int <b>gsl_vector_sub</b><i> (gsl_vector * <var>a</var>, const gsl_vector * <var>b</var>)</i></dt>
<dd><p>This function subtracts the elements of vector <var>b</var> from the elements of
vector <var>a</var>.  The result <em>a_i \leftarrow a_i - b_i</em> is stored
in <var>a</var> and <var>b</var> remains unchanged.  The two vectors must have the
same length.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fmul"></a><u>Function:</u> int <b>gsl_vector_mul</b><i> (gsl_vector * <var>a</var>, const gsl_vector * <var>b</var>)</i></dt>
<dd><p>This function multiplies the elements of vector <var>a</var> by the
elements of vector <var>b</var>.  The result <em>a_i \leftarrow a_i *
b_i</em> is stored in <var>a</var> and <var>b</var> remains unchanged. The two
vectors must have the same length.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fdiv"></a><u>Function:</u> int <b>gsl_vector_div</b><i> (gsl_vector * <var>a</var>, const gsl_vector * <var>b</var>)</i></dt>
<dd><p>This function divides the elements of vector <var>a</var> by the elements
of vector <var>b</var>.  The result <em>a_i \leftarrow a_i / b_i</em> is
stored in <var>a</var> and <var>b</var> remains unchanged. The two vectors must
have the same length.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fscale"></a><u>Function:</u> int <b>gsl_vector_scale</b><i> (gsl_vector * <var>a</var>, const double <var>x</var>)</i></dt>
<dd><p>This function multiplies the elements of vector <var>a</var> by the
constant factor <var>x</var>.  The result <em>a_i \leftarrow x a_i</em> is
stored in <var>a</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fadd_005fconstant"></a><u>Function:</u> int <b>gsl_vector_add_constant</b><i> (gsl_vector * <var>a</var>, const double <var>x</var>)</i></dt>
<dd><p>This function adds the constant value <var>x</var> to the elements of the
vector <var>a</var>.  The result <em>a_i \leftarrow a_i + x</em> is stored in
<var>a</var>.
</p></dd></dl>

<hr size="6">
<a name="Finding-maximum-and-minimum-elements-of-vectors"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Vector-operations" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-properties" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Finding-maximum-and-minimum-elements-of-vectors-1"></a>
<h3 class="subsection">3.9 Finding maximum and minimum elements of vectors</h3>

<p>The following operations are only defined for real vectors.
</p>
<dl>
<dt><a name="index-gsl_005fvector_005fmax"></a><u>Function:</u> double <b>gsl_vector_max</b><i> (const gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function returns the maximum value in the vector <var>v</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fmin"></a><u>Function:</u> double <b>gsl_vector_min</b><i> (const gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function returns the minimum value in the vector <var>v</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fminmax"></a><u>Function:</u> void <b>gsl_vector_minmax</b><i> (const gsl_vector * <var>v</var>, double * <var>min_out</var>, double * <var>max_out</var>)</i></dt>
<dd><p>This function returns the minimum and maximum values in the vector
<var>v</var>, storing them in <var>min_out</var> and <var>max_out</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fmax_005findex"></a><u>Function:</u> size_t <b>gsl_vector_max_index</b><i> (const gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function returns the index of the maximum value in the vector <var>v</var>.
When there are several equal maximum elements then the lowest index is
returned.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fmin_005findex"></a><u>Function:</u> size_t <b>gsl_vector_min_index</b><i> (const gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function returns the index of the minimum value in the vector <var>v</var>.
When there are several equal minimum elements then the lowest index is
returned.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fminmax_005findex"></a><u>Function:</u> void <b>gsl_vector_minmax_index</b><i> (const gsl_vector * <var>v</var>, size_t * <var>imin</var>, size_t * <var>imax</var>)</i></dt>
<dd><p>This function returns the indices of the minimum and maximum values in
the vector <var>v</var>, storing them in <var>imin</var> and <var>imax</var>. When
there are several equal minimum or maximum elements then the lowest
indices are returned.
</p></dd></dl>

<hr size="6">
<a name="Vector-properties"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Finding-maximum-and-minimum-elements-of-vectors" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Example-programs-for-vectors" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Vector-properties-1"></a>
<h3 class="subsection">3.10 Vector properties</h3>

<p>The following functions are defined for real and complex vectors.  For
complex vectors both the real and imaginary parts must satisfy the
conditions.
</p>
<dl>
<dt><a name="index-gsl_005fvector_005fisnull"></a><u>Function:</u> int <b>gsl_vector_isnull</b><i> (const gsl_vector * <var>v</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fispos"></a><u>Function:</u> int <b>gsl_vector_ispos</b><i> (const gsl_vector * <var>v</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fisneg"></a><u>Function:</u> int <b>gsl_vector_isneg</b><i> (const gsl_vector * <var>v</var>)</i></dt>
<dt><a name="index-gsl_005fvector_005fisnonneg"></a><u>Function:</u> int <b>gsl_vector_isnonneg</b><i> (const gsl_vector * <var>v</var>)</i></dt>
<dd><p>These functions return 1 if all the elements of the vector <var>v</var> are
zero, strictly positive, strictly negative, or non-negative
respectively, and 0 otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fvector_005fequal"></a><u>Function:</u> int <b>gsl_vector_equal</b><i> (const gsl_vector * <var>u</var>, const gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function returns 1 if the vectors <var>u</var> and <var>v</var> are equal
(by comparison of element values) and 0 otherwise.
</p></dd></dl>


<hr size="6">
<a name="Example-programs-for-vectors"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Vector-properties" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vectors" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Example-programs-for-vectors-1"></a>
<h3 class="subsection">3.11 Example programs for vectors</h3>

<p>This program shows how to allocate, initialize and read from a vector
using the functions <code>gsl_vector_alloc</code>, <code>gsl_vector_set</code> and
<code>gsl_vector_get</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_vector.h&gt;

int
main (void)
{
  int i;
  gsl_vector * v = gsl_vector_alloc (3);
  
  for (i = 0; i &lt; 3; i++)
    {
      gsl_vector_set (v, i, 1.23 + i);
    }
  
  for (i = 0; i &lt; 100; i++) /* OUT OF RANGE ERROR */
    {
      printf (&quot;v_%d = %g\n&quot;, i, gsl_vector_get (v, i));
    }

  gsl_vector_free (v);
  return 0;
}
</pre></pre></td></tr></table>

<p>Here is the output from the program.  The final loop attempts to read
outside the range of the vector <code>v</code>, and the error is trapped by
the range-checking code in <code>gsl_vector_get</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">$ ./a.out
v_0 = 1.23
v_1 = 2.23
v_2 = 3.23
gsl: vector_source.c:12: ERROR: index out of range
Default GSL error handler invoked.
Aborted (core dumped)
</pre></td></tr></table>

<p>The next program shows how to write a vector to a file.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_vector.h&gt;

int
main (void)
{
  int i; 
  gsl_vector * v = gsl_vector_alloc (100);
  
  for (i = 0; i &lt; 100; i++)
    {
      gsl_vector_set (v, i, 1.23 + i);
    }

  {  
     FILE * f = fopen (&quot;test.dat&quot;, &quot;w&quot;);
     gsl_vector_fprintf (f, v, &quot;%.5g&quot;);
     fclose (f);
  }

  gsl_vector_free (v);
  return 0;
}
</pre></pre></td></tr></table>

<p>After running this program the file &lsquo;<tt>test.dat</tt>&rsquo; should contain the
elements of <code>v</code>, written using the format specifier
<code>%.5g</code>.  The vector could then be read back in using the function
<code>gsl_vector_fscanf (f, v)</code> as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_vector.h&gt;

int
main (void)
{
  int i; 
  gsl_vector * v = gsl_vector_alloc (10);

  {  
     FILE * f = fopen (&quot;test.dat&quot;, &quot;r&quot;);
     gsl_vector_fscanf (f, v);
     fclose (f);
  }

  for (i = 0; i &lt; 10; i++)
    {
      printf (&quot;%g\n&quot;, gsl_vector_get(v, i));
    }

  gsl_vector_free (v);
  return 0;
}
</pre></pre></td></tr></table>


<hr size="6">
<a name="Matrices"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Example-programs-for-vectors" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrix-allocation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Vectors" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-types" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Matrices-1"></a>
<h2 class="section">4. Matrices</h2>
<a name="index-matrices-1"></a>
<a name="index-physical-dimension_002c-matrices"></a>
<a name="index-trailing-dimension_002c-matrices"></a>
<a name="index-leading-dimension_002c-matrices"></a>
<a name="index-ordering_002c-matrix-elements"></a>

<p>Matrices are defined by a <code>gsl_matrix</code> structure which describes a
generalized slice of a block.  Like a vector it represents a set of
elements in an area of memory, but uses two indices instead of one.
</p>
<a name="index-gsl_005fmatrix"></a>
<p>The <code>gsl_matrix</code> structure contains six components, the two
dimensions of the matrix, a physical dimension, a pointer to the memory
where the elements of the matrix are stored, <var>data</var>, a pointer to
the block owned by the matrix <var>block</var>, if any, and an ownership
flag, <var>owner</var>.  The physical dimension determines the memory layout
and can differ from the matrix dimension to allow the use of
submatrices.  The <code>gsl_matrix</code> structure is very simple and looks
like this,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct
{
  size_t size1;
  size_t size2;
  size_t tda;
  double * data;
  gsl_block * block;
  int owner;
} gsl_matrix;
</pre></td></tr></table>

<p>Matrices are stored in row-major order, meaning that each row of
elements forms a contiguous block in memory.  This is the standard
&ldquo;C-language ordering&rdquo; of two-dimensional arrays. Note that <small>FORTRAN</small>
stores arrays in column-major order. The number of rows is <var>size1</var>.
The range of valid row indices runs from 0 to <code>size1-1</code>.  Similarly
<var>size2</var> is the number of columns.  The range of valid column indices
runs from 0 to <code>size2-1</code>.  The physical row dimension <var>tda</var>, or
<em>trailing dimension</em>, specifies the size of a row of the matrix as
laid out in memory.
</p>
<p>For example, in the following matrix <var>size1</var> is 3, <var>size2</var> is 4,
and <var>tda</var> is 8.  The physical memory layout of the matrix begins in
the top left hand-corner and proceeds from left to right along each row
in turn.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">00 01 02 03 XX XX XX XX
10 11 12 13 XX XX XX XX
20 21 22 23 XX XX XX XX
</pre></td></tr></table>

<p>Each unused memory location is represented by &ldquo;<code>XX</code>&rdquo;.  The
pointer <var>data</var> gives the location of the first element of the matrix
in memory.  The pointer <var>block</var> stores the location of the memory
block in which the elements of the matrix are located (if any).  If the
matrix owns this block then the <var>owner</var> field is set to one and the
block will be deallocated when the matrix is freed.  If the matrix is
only a slice of a block owned by another object then the <var>owner</var> field is
zero and any underlying block will not be freed.
</p>
<p>The functions for allocating and accessing matrices are defined in
&lsquo;<tt>gsl_matrix.h</tt>&rsquo;
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#Matrix-allocation">4.1 Matrix allocation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           
</td></tr>
<tr><td align="left" valign="top"><a href="#Accessing-matrix-elements">4.2 Accessing matrix elements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">   
</td></tr>
<tr><td align="left" valign="top"><a href="#Initializing-matrix-elements">4.3 Initializing matrix elements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Reading-and-writing-matrices">4.4 Reading and writing matrices</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Matrix-views">4.5 Matrix views</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                
</td></tr>
<tr><td align="left" valign="top"><a href="#Creating-row-and-column-views">4.6 Creating row and column views</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Copying-matrices">4.7 Copying matrices</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">            
</td></tr>
<tr><td align="left" valign="top"><a href="#Copying-rows-and-columns">4.8 Copying rows and columns</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    
</td></tr>
<tr><td align="left" valign="top"><a href="#Exchanging-rows-and-columns">4.9 Exchanging rows and columns</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Matrix-operations">4.10 Matrix operations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           
</td></tr>
<tr><td align="left" valign="top"><a href="#Finding-maximum-and-minimum-elements-of-matrices">4.11 Finding maximum and minimum elements of matrices</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
<tr><td align="left" valign="top"><a href="#Matrix-properties">4.12 Matrix properties</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">           
</td></tr>
<tr><td align="left" valign="top"><a href="#Example-programs-for-matrices">4.13 Example programs for matrices</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  
</td></tr>
</table>

<hr size="6">
<a name="Matrix-allocation"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Matrices" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Accessing-matrix-elements" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Matrix-allocation-1"></a>
<h3 class="subsection">4.1 Matrix allocation</h3>

<p>The functions for allocating memory to a matrix follow the style of
<code>malloc</code> and <code>free</code>.  They also perform their own error
checking.  If there is insufficient memory available to allocate a matrix
then the functions call the GSL error handler (with an error number of
<code>GSL_ENOMEM</code>) in addition to returning a null pointer.  Thus if you
use the library error handler to abort your program then it isn&rsquo;t
necessary to check every <code>alloc</code>.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005falloc"></a><u>Function:</u> gsl_matrix * <b>gsl_matrix_alloc</b><i> (size_t <var>n1</var>, size_t <var>n2</var>)</i></dt>
<dd><p>This function creates a matrix of size <var>n1</var> rows by <var>n2</var>
columns, returning a pointer to a newly initialized matrix struct. A new
block is allocated for the elements of the matrix, and stored in the
<var>block</var> component of the matrix struct.  The block is &ldquo;owned&rdquo; by the
matrix, and will be deallocated when the matrix is deallocated.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fcalloc"></a><u>Function:</u> gsl_matrix * <b>gsl_matrix_calloc</b><i> (size_t <var>n1</var>, size_t <var>n2</var>)</i></dt>
<dd><p>This function allocates memory for a matrix of size <var>n1</var> rows by
<var>n2</var> columns and initializes all the elements of the matrix to zero.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005ffree"></a><u>Function:</u> void <b>gsl_matrix_free</b><i> (gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function frees a previously allocated matrix <var>m</var>.  If the
matrix was created using <code>gsl_matrix_alloc</code> then the block
underlying the matrix will also be deallocated.  If the matrix has
been created from another object then the memory is still owned by
that object and will not be deallocated.
</p></dd></dl>

<hr size="6">
<a name="Accessing-matrix-elements"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Matrix-allocation" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Initializing-matrix-elements" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Accessing-matrix-elements-1"></a>
<h3 class="subsection">4.2 Accessing matrix elements</h3>
<a name="index-matrices_002c-range_002dchecking"></a>
<a name="index-range_002dchecking-for-matrices"></a>

<p>The functions for accessing the elements of a matrix use the same range
checking system as vectors.  You can turn off range checking by recompiling
your program with the preprocessor definition
<code>GSL_RANGE_CHECK_OFF</code>.
</p>
<p>The elements of the matrix are stored in &ldquo;C-order&rdquo;, where the second
index moves continuously through memory.  More precisely, the element
accessed by the function <code>gsl_matrix_get(m,i,j)</code> and
<code>gsl_matrix_set(m,i,j,x)</code> is 
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">m-&gt;data[i * m-&gt;tda + j]
</pre></td></tr></table>

<p>where <var>tda</var> is the physical row-length of the matrix.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005fget"></a><u>Function:</u> double <b>gsl_matrix_get</b><i> (const gsl_matrix * <var>m</var>, const size_t <var>i</var>, const size_t <var>j</var>)</i></dt>
<dd><p>This function returns the <em>(i,j)</em>-th element of a matrix
<var>m</var>.  If <var>i</var> or <var>j</var> lie outside the allowed range of 0 to
<em><var>n1</var>-1</em> and 0 to <em><var>n2</var>-1</em> then the error handler is invoked and 0
is returned.  @inlinefn{}
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fset"></a><u>Function:</u> void <b>gsl_matrix_set</b><i> (gsl_matrix * <var>m</var>, const size_t <var>i</var>, const size_t <var>j</var>, double <var>x</var>)</i></dt>
<dd><p>This function sets the value of the <em>(i,j)</em>-th element of a
matrix <var>m</var> to <var>x</var>.  If <var>i</var> or <var>j</var> lies outside the
allowed range of 0 to <em><var>n1</var>-1</em> and 0 to <em><var>n2</var>-1</em> then the error
handler is invoked.  @inlinefn{}
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fptr"></a><u>Function:</u> double * <b>gsl_matrix_ptr</b><i> (gsl_matrix * <var>m</var>, size_t <var>i</var>, size_t <var>j</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fptr"></a><u>Function:</u> const double * <b>gsl_matrix_const_ptr</b><i> (const gsl_matrix * <var>m</var>, size_t <var>i</var>, size_t <var>j</var>)</i></dt>
<dd><p>These functions return a pointer to the <em>(i,j)</em>-th element of a
matrix <var>m</var>.  If <var>i</var> or <var>j</var> lie outside the allowed range of
0 to <em><var>n1</var>-1</em> and 0 to <em><var>n2</var>-1</em> then the error handler is invoked
and a null pointer is returned.  @inlinefns{}
</p></dd></dl>

<hr size="6">
<a name="Initializing-matrix-elements"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Accessing-matrix-elements" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Reading-and-writing-matrices" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Initializing-matrix-elements-1"></a>
<h3 class="subsection">4.3 Initializing matrix elements</h3>
<a name="index-matrices_002c-initializing"></a>
<a name="index-initializing-matrices"></a>
<a name="index-identity-matrix"></a>
<a name="index-matrix_002c-identity"></a>
<a name="index-zero-matrix"></a>
<a name="index-matrix_002c-zero"></a>
<a name="index-constant-matrix"></a>
<a name="index-matrix_002c-constant"></a>

<dl>
<dt><a name="index-gsl_005fmatrix_005fset_005fall"></a><u>Function:</u> void <b>gsl_matrix_set_all</b><i> (gsl_matrix * <var>m</var>, double <var>x</var>)</i></dt>
<dd><p>This function sets all the elements of the matrix <var>m</var> to the value
<var>x</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fset_005fzero"></a><u>Function:</u> void <b>gsl_matrix_set_zero</b><i> (gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function sets all the elements of the matrix <var>m</var> to zero.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fset_005fidentity"></a><u>Function:</u> void <b>gsl_matrix_set_identity</b><i> (gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function sets the elements of the matrix <var>m</var> to the
corresponding elements of the identity matrix, <em>m(i,j) =
\delta(i,j)</em>, i.e. a unit diagonal with all off-diagonal elements zero.
This applies to both square and rectangular matrices.
</p></dd></dl>

<hr size="6">
<a name="Reading-and-writing-matrices"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Initializing-matrix-elements" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrix-views" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Reading-and-writing-matrices-1"></a>
<h3 class="subsection">4.4 Reading and writing matrices</h3>

<p>The library provides functions for reading and writing matrices to a file
as binary data or formatted text.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005ffwrite"></a><u>Function:</u> int <b>gsl_matrix_fwrite</b><i> (FILE * <var>stream</var>, const gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function writes the elements of the matrix <var>m</var> to the stream
<var>stream</var> in binary format.  The return value is 0 for success and
<code>GSL_EFAILED</code> if there was a problem writing to the file.  Since the
data is written in the native binary format it may not be portable
between different architectures.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005ffread"></a><u>Function:</u> int <b>gsl_matrix_fread</b><i> (FILE * <var>stream</var>, gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function reads into the matrix <var>m</var> from the open stream
<var>stream</var> in binary format.  The matrix <var>m</var> must be preallocated
with the correct dimensions since the function uses the size of <var>m</var> to
determine how many bytes to read.  The return value is 0 for success and
<code>GSL_EFAILED</code> if there was a problem reading from the file.  The
data is assumed to have been written in the native binary format on the
same architecture.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005ffprintf"></a><u>Function:</u> int <b>gsl_matrix_fprintf</b><i> (FILE * <var>stream</var>, const gsl_matrix * <var>m</var>, const char * <var>format</var>)</i></dt>
<dd><p>This function writes the elements of the matrix <var>m</var> line-by-line to
the stream <var>stream</var> using the format specifier <var>format</var>, which
should be one of the <code>%g</code>, <code>%e</code> or <code>%f</code> formats for
floating point numbers and <code>%d</code> for integers.  The function returns
0 for success and <code>GSL_EFAILED</code> if there was a problem writing to
the file.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005ffscanf"></a><u>Function:</u> int <b>gsl_matrix_fscanf</b><i> (FILE * <var>stream</var>, gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function reads formatted data from the stream <var>stream</var> into the
matrix <var>m</var>.  The matrix <var>m</var> must be preallocated with the correct
dimensions since the function uses the size of <var>m</var> to determine how many
numbers to read.  The function returns 0 for success and
<code>GSL_EFAILED</code> if there was a problem reading from the file.
</p></dd></dl>

<hr size="6">
<a name="Matrix-views"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Reading-and-writing-matrices" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Creating-row-and-column-views" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Matrix-views-1"></a>
<h3 class="subsection">4.5 Matrix views</h3>
<a name="index-gsl_005fmatrix_005fview"></a>
<a name="index-gsl_005fmatrix_005fconst_005fview"></a>

<p>A matrix view is a temporary object, stored on the stack, which can be
used to operate on a subset of matrix elements.  Matrix views can be
defined for both constant and non-constant matrices using separate types
that preserve constness.  A matrix view has the type
<code>gsl_matrix_view</code> and a constant matrix view has the type
<code>gsl_matrix_const_view</code>.  In both cases the elements of the view
can by accessed using the <code>matrix</code> component of the view object.  A
pointer <code>gsl_matrix *</code> or <code>const gsl_matrix *</code> can be obtained
by taking the address of the <code>matrix</code> component with the <code>&amp;</code>
operator.  In addition to matrix views it is also possible to create
vector views of a matrix, such as row or column views.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005fsubmatrix"></a><u>Function:</u> gsl_matrix_view <b>gsl_matrix_submatrix</b><i> (gsl_matrix * <var>m</var>, size_t <var>k1</var>, size_t <var>k2</var>, size_t <var>n1</var>, size_t <var>n2</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fsubmatrix"></a><u>Function:</u> gsl_matrix_const_view <b>gsl_matrix_const_submatrix</b><i> (const gsl_matrix * <var>m</var>, size_t <var>k1</var>, size_t <var>k2</var>, size_t <var>n1</var>, size_t <var>n2</var>)</i></dt>
<dd><p>These functions return a matrix view of a submatrix of the matrix
<var>m</var>.  The upper-left element of the submatrix is the element
(<var>k1</var>,<var>k2</var>) of the original matrix.  The submatrix has <var>n1</var>
rows and <var>n2</var> columns.  The physical number of columns in memory
given by <var>tda</var> is unchanged.  Mathematically, the
<em>(i,j)</em>-th element of the new matrix is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">m'(i,j) = m-&gt;data[(k1*m-&gt;tda + k2) + i*m-&gt;tda + j]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n1-1</code> and the index <var>j</var>
runs from 0 to <code>n2-1</code>.
</p>
<p>The <code>data</code> pointer of the returned matrix struct is set to null if
the combined parameters (<var>i</var>,<var>j</var>,<var>n1</var>,<var>n2</var>,<var>tda</var>)
overrun the ends of the original matrix.
</p>
<p>The new matrix view is only a view of the block underlying the existing
matrix, <var>m</var>.  The block containing the elements of <var>m</var> is not
owned by the new matrix view.  When the view goes out of scope the
original matrix <var>m</var> and its block will continue to exist.  The
original memory can only be deallocated by freeing the original matrix.
Of course, the original matrix should not be deallocated while the view
is still in use.
</p>
<p>The function <code>gsl_matrix_const_submatrix</code> is equivalent to
<code>gsl_matrix_submatrix</code> but can be used for matrices which are
declared <code>const</code>.
</p></dd></dl>


<dl>
<dt><a name="index-gsl_005fmatrix_005fview_005farray"></a><u>Function:</u> gsl_matrix_view <b>gsl_matrix_view_array</b><i> (double * <var>base</var>, size_t <var>n1</var>, size_t <var>n2</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fview_005farray"></a><u>Function:</u> gsl_matrix_const_view <b>gsl_matrix_const_view_array</b><i> (const double * <var>base</var>, size_t <var>n1</var>, size_t <var>n2</var>)</i></dt>
<dd><p>These functions return a matrix view of the array <var>base</var>.  The
matrix has <var>n1</var> rows and <var>n2</var> columns.  The physical number of
columns in memory is also given by <var>n2</var>.  Mathematically, the
<em>(i,j)</em>-th element of the new matrix is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">m'(i,j) = base[i*n2 + j]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n1-1</code> and the index <var>j</var>
runs from 0 to <code>n2-1</code>.
</p>
<p>The new matrix is only a view of the array <var>base</var>.  When the view
goes out of scope the original array <var>base</var> will continue to exist.
The original memory can only be deallocated by freeing the original
array.  Of course, the original array should not be deallocated while
the view is still in use.
</p>
<p>The function <code>gsl_matrix_const_view_array</code> is equivalent to
<code>gsl_matrix_view_array</code> but can be used for matrices which are
declared <code>const</code>.
</p></dd></dl>


<dl>
<dt><a name="index-gsl_005fmatrix_005fview_005farray_005fwith_005ftda"></a><u>Function:</u> gsl_matrix_view <b>gsl_matrix_view_array_with_tda</b><i> (double * <var>base</var>, size_t <var>n1</var>, size_t <var>n2</var>, size_t <var>tda</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fview_005farray_005fwith_005ftda"></a><u>Function:</u> gsl_matrix_const_view <b>gsl_matrix_const_view_array_with_tda</b><i> (const double * <var>base</var>, size_t <var>n1</var>, size_t <var>n2</var>, size_t <var>tda</var>)</i></dt>
<dd><p>These functions return a matrix view of the array <var>base</var> with a
physical number of columns <var>tda</var> which may differ from the corresponding
dimension of the matrix.  The matrix has <var>n1</var> rows and <var>n2</var>
columns, and the physical number of columns in memory is given by
<var>tda</var>.  Mathematically, the <em>(i,j)</em>-th element of the new
matrix is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">m'(i,j) = base[i*tda + j]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n1-1</code> and the index <var>j</var>
runs from 0 to <code>n2-1</code>.
</p>
<p>The new matrix is only a view of the array <var>base</var>.  When the view
goes out of scope the original array <var>base</var> will continue to exist.
The original memory can only be deallocated by freeing the original
array.  Of course, the original array should not be deallocated while
the view is still in use.
</p>
<p>The function <code>gsl_matrix_const_view_array_with_tda</code> is equivalent
to <code>gsl_matrix_view_array_with_tda</code> but can be used for matrices
which are declared <code>const</code>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fview_005fvector"></a><u>Function:</u> gsl_matrix_view <b>gsl_matrix_view_vector</b><i> (gsl_vector * <var>v</var>, size_t <var>n1</var>, size_t <var>n2</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fview_005fvector"></a><u>Function:</u> gsl_matrix_const_view <b>gsl_matrix_const_view_vector</b><i> (const gsl_vector * <var>v</var>, size_t <var>n1</var>, size_t <var>n2</var>)</i></dt>
<dd><p>These functions return a matrix view of the vector <var>v</var>.  The matrix
has <var>n1</var> rows and <var>n2</var> columns. The vector must have unit
stride. The physical number of columns in memory is also given by
<var>n2</var>.  Mathematically, the <em>(i,j)</em>-th element of the new
matrix is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">m'(i,j) = v-&gt;data[i*n2 + j]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n1-1</code> and the index <var>j</var>
runs from 0 to <code>n2-1</code>.
</p>
<p>The new matrix is only a view of the vector <var>v</var>.  When the view
goes out of scope the original vector <var>v</var> will continue to exist.
The original memory can only be deallocated by freeing the original
vector.  Of course, the original vector should not be deallocated while
the view is still in use.
</p>
<p>The function <code>gsl_matrix_const_view_vector</code> is equivalent to
<code>gsl_matrix_view_vector</code> but can be used for matrices which are
declared <code>const</code>.
</p></dd></dl>


<dl>
<dt><a name="index-gsl_005fmatrix_005fview_005fvector_005fwith_005ftda"></a><u>Function:</u> gsl_matrix_view <b>gsl_matrix_view_vector_with_tda</b><i> (gsl_vector * <var>v</var>, size_t <var>n1</var>, size_t <var>n2</var>, size_t <var>tda</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fview_005fvector_005fwith_005ftda"></a><u>Function:</u> gsl_matrix_const_view <b>gsl_matrix_const_view_vector_with_tda</b><i> (const gsl_vector * <var>v</var>, size_t <var>n1</var>, size_t <var>n2</var>, size_t <var>tda</var>)</i></dt>
<dd><p>These functions return a matrix view of the vector <var>v</var> with a
physical number of columns <var>tda</var> which may differ from the
corresponding matrix dimension.  The vector must have unit stride. The
matrix has <var>n1</var> rows and <var>n2</var> columns, and the physical number
of columns in memory is given by <var>tda</var>.  Mathematically, the
<em>(i,j)</em>-th element of the new matrix is given by,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">m'(i,j) = v-&gt;data[i*tda + j]
</pre></td></tr></table>

<p>where the index <var>i</var> runs from 0 to <code>n1-1</code> and the index <var>j</var>
runs from 0 to <code>n2-1</code>.
</p>
<p>The new matrix is only a view of the vector <var>v</var>.  When the view
goes out of scope the original vector <var>v</var> will continue to exist.
The original memory can only be deallocated by freeing the original
vector.  Of course, the original vector should not be deallocated while
the view is still in use.
</p>
<p>The function <code>gsl_matrix_const_view_vector_with_tda</code> is equivalent
to <code>gsl_matrix_view_vector_with_tda</code> but can be used for matrices
which are declared <code>const</code>.
</p></dd></dl>



<hr size="6">
<a name="Creating-row-and-column-views"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Matrix-views" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Copying-matrices" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Creating-row-and-column-views-1"></a>
<h3 class="subsection">4.6 Creating row and column views</h3>

<p>In general there are two ways to access an object, by reference or by
copying.  The functions described in this section create vector views
which allow access to a row or column of a matrix by reference.
Modifying elements of the view is equivalent to modifying the matrix,
since both the vector view and the matrix point to the same memory
block.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005frow"></a><u>Function:</u> gsl_vector_view <b>gsl_matrix_row</b><i> (gsl_matrix * <var>m</var>, size_t <var>i</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005frow"></a><u>Function:</u> gsl_vector_const_view <b>gsl_matrix_const_row</b><i> (const gsl_matrix * <var>m</var>, size_t <var>i</var>)</i></dt>
<dd><p>These functions return a vector view of the <var>i</var>-th row of the matrix
<var>m</var>.  The <code>data</code> pointer of the new vector is set to null if
<var>i</var> is out of range.
</p>
<p>The function <code>gsl_vector_const_row</code> is equivalent to
<code>gsl_matrix_row</code> but can be used for matrices which are declared
<code>const</code>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fcolumn"></a><u>Function:</u> gsl_vector_view <b>gsl_matrix_column</b><i> (gsl_matrix * <var>m</var>, size_t <var>j</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fcolumn"></a><u>Function:</u> gsl_vector_const_view <b>gsl_matrix_const_column</b><i> (const gsl_matrix * <var>m</var>, size_t <var>j</var>)</i></dt>
<dd><p>These functions return a vector view of the <var>j</var>-th column of the
matrix <var>m</var>.  The <code>data</code> pointer of the new vector is set to
null if <var>j</var> is out of range.
</p>
<p>The function <code>gsl_vector_const_column</code> is equivalent to
<code>gsl_matrix_column</code> but can be used for matrices which are declared
<code>const</code>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fsubrow"></a><u>Function:</u> gsl_vector_view <b>gsl_matrix_subrow</b><i> (gsl_matrix * <var>m</var>, size_t <var>i</var>, size_t <var>offset</var>, size_t <var>n</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fsubrow"></a><u>Function:</u> gsl_vector_const_view <b>gsl_matrix_const_subrow</b><i> (const gsl_matrix * <var>m</var>, size_t <var>i</var>, size_t <var>offset</var>, size_t <var>n</var>)</i></dt>
<dd><p>These functions return a vector view of the <var>i</var>-th row of the matrix
<var>m</var> beginning at <var>offset</var> elements past the first column and
containing <var>n</var> elements. The <code>data</code> pointer of the new vector
is set to null if <var>i</var>, <var>offset</var>, or <var>n</var> are out of range.
</p>
<p>The function <code>gsl_vector_const_subrow</code> is equivalent to
<code>gsl_matrix_subrow</code> but can be used for matrices which are declared
<code>const</code>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fsubcolumn"></a><u>Function:</u> gsl_vector_view <b>gsl_matrix_subcolumn</b><i> (gsl_matrix * <var>m</var>, size_t <var>j</var>, size_t <var>offset</var>, size_t <var>n</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fsubcolumn"></a><u>Function:</u> gsl_vector_const_view <b>gsl_matrix_const_subcolumn</b><i> (const gsl_matrix * <var>m</var>, size_t <var>j</var>, size_t <var>offset</var>, size_t <var>n</var>)</i></dt>
<dd><p>These functions return a vector view of the <var>j</var>-th column of the matrix
<var>m</var> beginning at <var>offset</var> elements past the first row and
containing <var>n</var> elements. The <code>data</code> pointer of the new vector
is set to null if <var>j</var>, <var>offset</var>, or <var>n</var> are out of range.
</p>
<p>The function <code>gsl_vector_const_subcolumn</code> is equivalent to
<code>gsl_matrix_subcolumn</code> but can be used for matrices which are declared
<code>const</code>.
</p></dd></dl>

<a name="index-matrix-diagonal"></a>
<a name="index-diagonal_002c-of-a-matrix"></a>
<dl>
<dt><a name="index-gsl_005fmatrix_005fdiagonal"></a><u>Function:</u> gsl_vector_view <b>gsl_matrix_diagonal</b><i> (gsl_matrix * <var>m</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fdiagonal"></a><u>Function:</u> gsl_vector_const_view <b>gsl_matrix_const_diagonal</b><i> (const gsl_matrix * <var>m</var>)</i></dt>
<dd><p>These functions return a vector view of the diagonal of the matrix
<var>m</var>. The matrix <var>m</var> is not required to be square. For a
rectangular matrix the length of the diagonal is the same as the smaller
dimension of the matrix.
</p>
<p>The function <code>gsl_matrix_const_diagonal</code> is equivalent to
<code>gsl_matrix_diagonal</code> but can be used for matrices which are
declared <code>const</code>.
</p></dd></dl>

<a name="index-matrix-subdiagonal"></a>
<a name="index-subdiagonal_002c-of-a-matrix"></a>
<dl>
<dt><a name="index-gsl_005fmatrix_005fsubdiagonal"></a><u>Function:</u> gsl_vector_view <b>gsl_matrix_subdiagonal</b><i> (gsl_matrix * <var>m</var>, size_t <var>k</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fsubdiagonal"></a><u>Function:</u> gsl_vector_const_view <b>gsl_matrix_const_subdiagonal</b><i> (const gsl_matrix * <var>m</var>, size_t <var>k</var>)</i></dt>
<dd><p>These functions return a vector view of the <var>k</var>-th subdiagonal of
the matrix <var>m</var>. The matrix <var>m</var> is not required to be square.
The diagonal of the matrix corresponds to <em>k = 0</em>.
</p>
<p>The function <code>gsl_matrix_const_subdiagonal</code> is equivalent to
<code>gsl_matrix_subdiagonal</code> but can be used for matrices which are
declared <code>const</code>.
</p></dd></dl>

<a name="index-matrix-superdiagonal"></a>
<a name="index-superdiagonal_002c-matrix"></a>
<dl>
<dt><a name="index-gsl_005fmatrix_005fsuperdiagonal"></a><u>Function:</u> gsl_vector_view <b>gsl_matrix_superdiagonal</b><i> (gsl_matrix * <var>m</var>, size_t <var>k</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fconst_005fsuperdiagonal"></a><u>Function:</u> gsl_vector_const_view <b>gsl_matrix_const_superdiagonal</b><i> (const gsl_matrix * <var>m</var>, size_t <var>k</var>)</i></dt>
<dd><p>These functions return a vector view of the <var>k</var>-th superdiagonal of
the matrix <var>m</var>. The matrix <var>m</var> is not required to be square. The
diagonal of the matrix corresponds to <em>k = 0</em>.
</p>
<p>The function <code>gsl_matrix_const_superdiagonal</code> is equivalent to
<code>gsl_matrix_superdiagonal</code> but can be used for matrices which are
declared <code>const</code>.
</p></dd></dl>


<hr size="6">
<a name="Copying-matrices"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Creating-row-and-column-views" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Copying-rows-and-columns" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Copying-matrices-1"></a>
<h3 class="subsection">4.7 Copying matrices</h3>

<dl>
<dt><a name="index-gsl_005fmatrix_005fmemcpy"></a><u>Function:</u> int <b>gsl_matrix_memcpy</b><i> (gsl_matrix * <var>dest</var>, const gsl_matrix * <var>src</var>)</i></dt>
<dd><p>This function copies the elements of the matrix <var>src</var> into the
matrix <var>dest</var>.  The two matrices must have the same size.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fswap"></a><u>Function:</u> int <b>gsl_matrix_swap</b><i> (gsl_matrix * <var>m1</var>, gsl_matrix * <var>m2</var>)</i></dt>
<dd><p>This function exchanges the elements of the matrices <var>m1</var> and
<var>m2</var> by copying.  The two matrices must have the same size.
</p></dd></dl>

<hr size="6">
<a name="Copying-rows-and-columns"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Copying-matrices" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Exchanging-rows-and-columns" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Copying-rows-and-columns-1"></a>
<h3 class="subsection">4.8 Copying rows and columns</h3>

<p>The functions described in this section copy a row or column of a matrix
into a vector.  This allows the elements of the vector and the matrix to
be modified independently.  Note that if the matrix and the vector point
to overlapping regions of memory then the result will be undefined.  The
same effect can be achieved with more generality using
<code>gsl_vector_memcpy</code> with vector views of rows and columns.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005fget_005frow"></a><u>Function:</u> int <b>gsl_matrix_get_row</b><i> (gsl_vector * <var>v</var>, const gsl_matrix * <var>m</var>, size_t <var>i</var>)</i></dt>
<dd><p>This function copies the elements of the <var>i</var>-th row of the matrix
<var>m</var> into the vector <var>v</var>.  The length of the vector must be the
same as the length of the row.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fget_005fcol"></a><u>Function:</u> int <b>gsl_matrix_get_col</b><i> (gsl_vector * <var>v</var>, const gsl_matrix * <var>m</var>, size_t <var>j</var>)</i></dt>
<dd><p>This function copies the elements of the <var>j</var>-th column of the matrix
<var>m</var> into the vector <var>v</var>.  The length of the vector must be the
same as the length of the column.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fset_005frow"></a><u>Function:</u> int <b>gsl_matrix_set_row</b><i> (gsl_matrix * <var>m</var>, size_t <var>i</var>, const gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function copies the elements of the vector <var>v</var> into the
<var>i</var>-th row of the matrix <var>m</var>.  The length of the vector must be
the same as the length of the row.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fset_005fcol"></a><u>Function:</u> int <b>gsl_matrix_set_col</b><i> (gsl_matrix * <var>m</var>, size_t <var>j</var>, const gsl_vector * <var>v</var>)</i></dt>
<dd><p>This function copies the elements of the vector <var>v</var> into the
<var>j</var>-th column of the matrix <var>m</var>.  The length of the vector must be
the same as the length of the column.
</p></dd></dl>

<hr size="6">
<a name="Exchanging-rows-and-columns"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Copying-rows-and-columns" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrix-operations" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Exchanging-rows-and-columns-1"></a>
<h3 class="subsection">4.9 Exchanging rows and columns</h3>

<p>The following functions can be used to exchange the rows and columns of
a matrix.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005fswap_005frows"></a><u>Function:</u> int <b>gsl_matrix_swap_rows</b><i> (gsl_matrix * <var>m</var>, size_t <var>i</var>, size_t <var>j</var>)</i></dt>
<dd><p>This function exchanges the <var>i</var>-th and <var>j</var>-th rows of the matrix
<var>m</var> in-place.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fswap_005fcolumns"></a><u>Function:</u> int <b>gsl_matrix_swap_columns</b><i> (gsl_matrix * <var>m</var>, size_t <var>i</var>, size_t <var>j</var>)</i></dt>
<dd><p>This function exchanges the <var>i</var>-th and <var>j</var>-th columns of the
matrix <var>m</var> in-place.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fswap_005frowcol"></a><u>Function:</u> int <b>gsl_matrix_swap_rowcol</b><i> (gsl_matrix * <var>m</var>, size_t <var>i</var>, size_t <var>j</var>)</i></dt>
<dd><p>This function exchanges the <var>i</var>-th row and <var>j</var>-th column of the
matrix <var>m</var> in-place.  The matrix must be square for this operation to
be possible.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005ftranspose_005fmemcpy"></a><u>Function:</u> int <b>gsl_matrix_transpose_memcpy</b><i> (gsl_matrix * <var>dest</var>, const gsl_matrix * <var>src</var>)</i></dt>
<dd><p>This function makes the matrix <var>dest</var> the transpose of the matrix
<var>src</var> by copying the elements of <var>src</var> into <var>dest</var>.  This
function works for all matrices provided that the dimensions of the matrix
<var>dest</var> match the transposed dimensions of the matrix <var>src</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005ftranspose"></a><u>Function:</u> int <b>gsl_matrix_transpose</b><i> (gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function replaces the matrix <var>m</var> by its transpose by copying
the elements of the matrix in-place.  The matrix must be square for this
operation to be possible.
</p></dd></dl>

<hr size="6">
<a name="Matrix-operations"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Exchanging-rows-and-columns" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Finding-maximum-and-minimum-elements-of-matrices" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Matrix-operations-1"></a>
<h3 class="subsection">4.10 Matrix operations</h3>

<p>The following operations are defined for real and complex matrices.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005fadd"></a><u>Function:</u> int <b>gsl_matrix_add</b><i> (gsl_matrix * <var>a</var>, const gsl_matrix * <var>b</var>)</i></dt>
<dd><p>This function adds the elements of matrix <var>b</var> to the elements of
matrix <var>a</var>.  The result <em>a(i,j) \leftarrow a(i,j) + b(i,j)</em>
is stored in <var>a</var> and <var>b</var> remains unchanged. The two matrices
must have the same dimensions.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fsub"></a><u>Function:</u> int <b>gsl_matrix_sub</b><i> (gsl_matrix * <var>a</var>, const gsl_matrix * <var>b</var>)</i></dt>
<dd><p>This function subtracts the elements of matrix <var>b</var> from the
elements of matrix <var>a</var>.  The result <em>a(i,j) \leftarrow a(i,j)
- b(i,j)</em> is stored in <var>a</var> and <var>b</var> remains unchanged. The two
matrices must have the same dimensions.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fmul_005felements"></a><u>Function:</u> int <b>gsl_matrix_mul_elements</b><i> (gsl_matrix * <var>a</var>, const gsl_matrix * <var>b</var>)</i></dt>
<dd><p>This function multiplies the elements of matrix <var>a</var> by the
elements of matrix <var>b</var>.  The result <em>a(i,j) \leftarrow a(i,j)
* b(i,j)</em> is stored in <var>a</var> and <var>b</var> remains unchanged.  The two
matrices must have the same dimensions.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fdiv_005felements"></a><u>Function:</u> int <b>gsl_matrix_div_elements</b><i> (gsl_matrix * <var>a</var>, const gsl_matrix * <var>b</var>)</i></dt>
<dd><p>This function divides the elements of matrix <var>a</var> by the elements
of matrix <var>b</var>.  The result <em>a(i,j) \leftarrow a(i,j) /
b(i,j)</em> is stored in <var>a</var> and <var>b</var> remains unchanged. The two
matrices must have the same dimensions.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fscale"></a><u>Function:</u> int <b>gsl_matrix_scale</b><i> (gsl_matrix * <var>a</var>, const double <var>x</var>)</i></dt>
<dd><p>This function multiplies the elements of matrix <var>a</var> by the
constant factor <var>x</var>.  The result <em>a(i,j) \leftarrow x a(i,j)</em>
is stored in <var>a</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fadd_005fconstant"></a><u>Function:</u> int <b>gsl_matrix_add_constant</b><i> (gsl_matrix * <var>a</var>, const double <var>x</var>)</i></dt>
<dd><p>This function adds the constant value <var>x</var> to the elements of the
matrix <var>a</var>.  The result <em>a(i,j) \leftarrow a(i,j) + x</em> is
stored in <var>a</var>.
</p></dd></dl>

<hr size="6">
<a name="Finding-maximum-and-minimum-elements-of-matrices"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Matrix-operations" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrix-properties" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Finding-maximum-and-minimum-elements-of-matrices-1"></a>
<h3 class="subsection">4.11 Finding maximum and minimum elements of matrices</h3>

<p>The following operations are only defined for real matrices.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005fmax"></a><u>Function:</u> double <b>gsl_matrix_max</b><i> (const gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function returns the maximum value in the matrix <var>m</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fmin"></a><u>Function:</u> double <b>gsl_matrix_min</b><i> (const gsl_matrix * <var>m</var>)</i></dt>
<dd><p>This function returns the minimum value in the matrix <var>m</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fminmax"></a><u>Function:</u> void <b>gsl_matrix_minmax</b><i> (const gsl_matrix * <var>m</var>, double * <var>min_out</var>, double * <var>max_out</var>)</i></dt>
<dd><p>This function returns the minimum and maximum values in the matrix
<var>m</var>, storing them in <var>min_out</var> and <var>max_out</var>.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fmax_005findex"></a><u>Function:</u> void <b>gsl_matrix_max_index</b><i> (const gsl_matrix * <var>m</var>, size_t * <var>imax</var>, size_t * <var>jmax</var>)</i></dt>
<dd><p>This function returns the indices of the maximum value in the matrix
<var>m</var>, storing them in <var>imax</var> and <var>jmax</var>.  When there are
several equal maximum elements then the first element found is returned,
searching in row-major order.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fmin_005findex"></a><u>Function:</u> void <b>gsl_matrix_min_index</b><i> (const gsl_matrix * <var>m</var>, size_t * <var>imin</var>, size_t * <var>jmin</var>)</i></dt>
<dd><p>This function returns the indices of the minimum value in the matrix
<var>m</var>, storing them in <var>imin</var> and <var>jmin</var>.  When there are
several equal minimum elements then the first element found is returned,
searching in row-major order.
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fminmax_005findex"></a><u>Function:</u> void <b>gsl_matrix_minmax_index</b><i> (const gsl_matrix * <var>m</var>, size_t * <var>imin</var>, size_t * <var>jmin</var>, size_t * <var>imax</var>, size_t * <var>jmax</var>)</i></dt>
<dd><p>This function returns the indices of the minimum and maximum values in
the matrix <var>m</var>, storing them in (<var>imin</var>,<var>jmin</var>) and
(<var>imax</var>,<var>jmax</var>). When there are several equal minimum or maximum
elements then the first elements found are returned, searching in
row-major order.
</p></dd></dl>

<hr size="6">
<a name="Matrix-properties"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Finding-maximum-and-minimum-elements-of-matrices" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Example-programs-for-matrices" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Matrix-properties-1"></a>
<h3 class="subsection">4.12 Matrix properties</h3>

<p>The following functions are defined for real and complex matrices.
For complex matrices both the real and imaginary parts must satisfy
the conditions.
</p>
<dl>
<dt><a name="index-gsl_005fmatrix_005fisnull"></a><u>Function:</u> int <b>gsl_matrix_isnull</b><i> (const gsl_matrix * <var>m</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fispos"></a><u>Function:</u> int <b>gsl_matrix_ispos</b><i> (const gsl_matrix * <var>m</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fisneg"></a><u>Function:</u> int <b>gsl_matrix_isneg</b><i> (const gsl_matrix * <var>m</var>)</i></dt>
<dt><a name="index-gsl_005fmatrix_005fisnonneg"></a><u>Function:</u> int <b>gsl_matrix_isnonneg</b><i> (const gsl_matrix * <var>m</var>)</i></dt>
<dd><p>These functions return 1 if all the elements of the matrix <var>m</var> are
zero, strictly positive, strictly negative, or non-negative
respectively, and 0 otherwise. To test whether a matrix is
positive-definite, use the Cholesky decomposition (@pxref{Cholesky
Decomposition}).
</p></dd></dl>

<dl>
<dt><a name="index-gsl_005fmatrix_005fequal"></a><u>Function:</u> int <b>gsl_matrix_equal</b><i> (const gsl_matrix * <var>a</var>, const gsl_matrix * <var>b</var>)</i></dt>
<dd><p>This function returns 1 if the matrices <var>a</var> and <var>b</var> are equal
(by comparison of element values) and 0 otherwise.
</p></dd></dl>


<hr size="6">
<a name="Example-programs-for-matrices"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Matrix-properties" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Matrices" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="#Vector-and-Matrix-References-and-Further-Reading" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="Example-programs-for-matrices-1"></a>
<h3 class="subsection">4.13 Example programs for matrices</h3>

<p>The program below shows how to allocate, initialize and read from a matrix
using the functions <code>gsl_matrix_alloc</code>, <code>gsl_matrix_set</code> and
<code>gsl_matrix_get</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_matrix.h&gt;

int
main (void)
{
  int i, j; 
  gsl_matrix * m = gsl_matrix_alloc (10, 3);
  
  for (i = 0; i &lt; 10; i++)
    for (j = 0; j &lt; 3; j++)
      gsl_matrix_set (m, i, j, 0.23 + 100*i + j);
  
  for (i = 0; i &lt; 100; i++)  /* OUT OF RANGE ERROR */
    for (j = 0; j &lt; 3; j++)
      printf (&quot;m(%d,%d) = %g\n&quot;, i, j, 
              gsl_matrix_get (m, i, j));

  gsl_matrix_free (m);

  return 0;
}
</pre></pre></td></tr></table>

<p>Here is the output from the program.  The final loop attempts to read
outside the range of the matrix <code>m</code>, and the error is trapped by
the range-checking code in <code>gsl_matrix_get</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">$ ./a.out
m(0,0) = 0.23
m(0,1) = 1.23
m(0,2) = 2.23
m(1,0) = 100.23
m(1,1) = 101.23
m(1,2) = 102.23
...
m(9,2) = 902.23
gsl: matrix_source.c:13: ERROR: first index out of range
Default GSL error handler invoked.
Aborted (core dumped)
</pre></td></tr></table>

<p>The next program shows how to write a matrix to a file.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><pre class="verbatim">#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_matrix.h&gt;

int
main (void)
{
  int i, j, k = 0; 
  gsl_matrix * m = gsl_matrix_alloc (100, 100);
  gsl_matrix * a = gsl_matrix_alloc (100, 100);
  
  for (i = 0; i &lt; 100; i++)
    for (j = 0; j &lt; 100; j++)
      gsl_matrix_set (m, i, j, 0.23 + i + j);

  {  
     FILE * f = fopen (&quot;test.dat&quot;, &quot;wb&quot;);
     gsl_matrix_fwrite (f, m);
     fclose (f);
  }

  {  
     FILE * f = fopen (&quot;test.dat&quot;, &quot;rb&quot;);
     gsl_matrix_fread (f, a);
     fclose (f);
  }

  for (i = 0; i &lt; 100; i++)
    for (j = 0; j &lt; 100; j++)
      {
        double mij = gsl_matrix_get (m, i, j);
        double aij = gsl_matrix_get (a, i, j);
        if (mij != aij) k++;
      }

  gsl_matrix_free (m);
  gsl_matrix_free (a);

  printf (&quot;differences = %d (should be zero)\n&quot;, k);
  return (k &gt; 0);
}
</pre></pre></td></tr></table>

<p>After running this program the file &lsquo;<tt>test.dat</tt>&rsquo; should contain the
elements of <code>m</code>, written in binary format.  The matrix which is read
back in using the function <code>gsl_matrix_fread</code> should be exactly
equal to the original matrix.
</p>
<p>The following program demonstrates the use of vector views.  The program
computes the column norms of a matrix.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><pre class="verbatim">#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;gsl/gsl_matrix.h&gt;
#include &lt;gsl/gsl_blas.h&gt;

int
main (void)
{
  size_t i,j;

  gsl_matrix *m = gsl_matrix_alloc (10, 10);

  for (i = 0; i &lt; 10; i++)
    for (j = 0; j &lt; 10; j++)
      gsl_matrix_set (m, i, j, sin (i) + cos (j));

  for (j = 0; j &lt; 10; j++)
    {
      gsl_vector_view column = gsl_matrix_column (m, j);
      double d;

      d = gsl_blas_dnrm2 (&amp;column.vector);

      printf (&quot;matrix column %d, norm = %g\n&quot;, j, d);
    }

  gsl_matrix_free (m);

  return 0;
}
</pre></pre></td></tr></table>

<p>Here is the output of the program, 
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">$ ./a.out
<pre class="verbatim">matrix column 0, norm = 4.31461
matrix column 1, norm = 3.1205
matrix column 2, norm = 2.19316
matrix column 3, norm = 3.26114
matrix column 4, norm = 2.53416
matrix column 5, norm = 2.57281
matrix column 6, norm = 4.20469
matrix column 7, norm = 3.65202
matrix column 8, norm = 2.08524
matrix column 9, norm = 3.07313
</pre></pre></td></tr></table>

<p>The results can be confirmed using <small>GNU OCTAVE</small>,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">$ octave
GNU Octave, version 2.0.16.92
octave&gt; m = sin(0:9)' * ones(1,10) 
               + ones(10,1) * cos(0:9); 
octave&gt; sqrt(sum(m.^2))
ans =
  4.3146  3.1205  2.1932  3.2611  2.5342  2.5728
  4.2047  3.6520  2.0852  3.0731
</pre></td></tr></table>


<hr size="6">
<a name="Vector-and-Matrix-References-and-Further-Reading"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Example-programs-for-matrices" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[ &gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Matrices" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#Data-types" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<a name="References-and-Further-Reading"></a>
<h2 class="section">5. References and Further Reading</h2>

<p>The block, vector and matrix objects in GSL follow the <code>valarray</code>
model of C++.  A description of this model can be found in the following
reference,
</p>
<ul class="toc">
<li>
B. Stroustrup,
<cite>The C++ Programming Language</cite> (3rd Ed), 
Section 22.4 Vector Arithmetic.
Addison-Wesley 1997, ISBN 0-201-88954-4.
</li></ul>
<hr size="6">
<a name="SEC_Foot"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1>Footnotes</h1>
<h3><a name="FOOT1" href="#DOCF1">(1)</a></h3>
<p>Range
checking is available in the GNU C Compiler bounds-checking extension,
but it is not part of the default installation of GCC. Memory accesses
can also be checked with Valgrind or the <code>gcc -fmudflap</code>
memory protection option.
</p><hr size="1">
<a name="SEC_About"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#Data-types" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1>About This Document</h1>
<p>
  This document was generated by <em>A. Gerow</em> on <em>April 2, 2015</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
</p>
<p>
  The buttons in the navigation panels have the following meaning:
</p>
<table border="1">
  <tr>
    <th> Button </th>
    <th> Name </th>
    <th> Go to </th>
    <th> From 1.2.3 go to</th>
  </tr>
  <tr>
    <td align="center"> [ &lt; ] </td>
    <td align="center">Back</td>
    <td>Previous section in reading order</td>
    <td>1.2.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt; ] </td>
    <td align="center">Forward</td>
    <td>Next section in reading order</td>
    <td>1.2.4</td>
  </tr>
  <tr>
    <td align="center"> [ &lt;&lt; ] </td>
    <td align="center">FastBack</td>
    <td>Beginning of this chapter or previous chapter</td>
    <td>1</td>
  </tr>
  <tr>
    <td align="center"> [ Up ] </td>
    <td align="center">Up</td>
    <td>Up section</td>
    <td>1.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt;&gt; ] </td>
    <td align="center">FastForward</td>
    <td>Next chapter</td>
    <td>2</td>
  </tr>
  <tr>
    <td align="center"> [Top] </td>
    <td align="center">Top</td>
    <td>Cover (top) of document</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [Contents] </td>
    <td align="center">Contents</td>
    <td>Table of contents</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [Index] </td>
    <td align="center">Index</td>
    <td>Index</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [ ? ] </td>
    <td align="center">About</td>
    <td>About (help)</td>
    <td> &nbsp; </td>
  </tr>
</table>

<p>
  where the <strong> Example </strong> assumes that the current position is at <strong> Subsubsection One-Two-Three </strong> of a document of the following structure:
</p>

<ul>
  <li> 1. Section One
    <ul>
      <li>1.1 Subsection One-One
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.2 Subsection One-Two
        <ul>
          <li>1.2.1 Subsubsection One-Two-One</li>
          <li>1.2.2 Subsubsection One-Two-Two</li>
          <li>1.2.3 Subsubsection One-Two-Three &nbsp; &nbsp;
            <strong>&lt;== Current Position </strong></li>
          <li>1.2.4 Subsubsection One-Two-Four</li>
        </ul>
      </li>
      <li>1.3 Subsection One-Three
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.4 Subsection One-Four</li>
    </ul>
  </li>
</ul>

<hr size="1">
<p>
 <font size="-1">
  This document was generated by <em>A. Gerow</em> on <em>April 2, 2015</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
